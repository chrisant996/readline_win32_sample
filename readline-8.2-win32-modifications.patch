diff --git a/input.c b/input.c
index 6f038d4..e3c23af 100644
--- a/input.c
+++ b/input.c
@@ -140,18 +140,22 @@ win32_isatty (int fd)
 
 /* I don't know how to set a timeout for _getch() in MinGW32, so we use
    SIGALRM. */
+#if 0
 #if (defined (HAVE_PSELECT) || defined (HAVE_SELECT)) && !defined (__MINGW32__)
 #  define RL_TIMEOUT_USE_SELECT
 #else
 #  define RL_TIMEOUT_USE_SIGALRM
 #endif
+#endif
 
 int rl_set_timeout (unsigned int, unsigned int);
 int rl_timeout_remaining (unsigned int *, unsigned int *);
 
 int _rl_timeout_init (void);
 int _rl_timeout_sigalrm_handler (void);
+#if 0
 int _rl_timeout_select (int, fd_set *, fd_set *, fd_set *, const struct timeval *, const sigset_t *);
+#endif
 
 static void _rl_timeout_handle (void);
 #if defined (RL_TIMEOUT_USE_SIGALRM)
@@ -551,6 +555,7 @@ reset_alarm ()
 #  endif
 #endif
 
+#if 0
 /* Set a timeout which will be used for the next call of `readline
    ()'.  When (0, 0) are specified the timeout is cleared.  */
 int
@@ -561,6 +566,7 @@ rl_set_timeout (unsigned int secs, unsigned int usecs)
 
   return 0;
 }
+#endif
 
 /* Start measuring the time.  Returns 0 on success.  Returns -1 on
    error. */
@@ -649,6 +655,8 @@ rl_timeout_remaining (unsigned int *secs, unsigned int *usecs)
 
 /* This should only be called if RL_TIMEOUT_USE_SELECT is defined. */
 
+#if 0
+
 #if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
 int
 _rl_timeout_select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout, const sigset_t *sigmask)
@@ -741,6 +749,9 @@ _rl_timeout_handle_sigalrm ()
 #endif
   return -1;
 }
+
+#endif
+
 /* **************************************************************** */
 /*								    */
 /*			     Character Input			    */
@@ -818,7 +829,7 @@ rl_getc (FILE *stream)
       /* We know at this point that _rl_caught_signal == 0 */
 
 #if defined (__MINGW32__)
-      if (isatty (fd)
+      if (isatty (fd))
 	return (_getch ());	/* "There is no error return." */
 #endif
       result = 0;
@@ -877,7 +888,9 @@ rl_getc (FILE *stream)
 
 /* fprintf(stderr, "rl_getc: result = %d errno = %d\n", result, errno); */
 
+#if 0
 handle_error:
+#endif
       /* If the error that we received was EINTR, then try again,
 	 this is simply an interrupted system call to read ().  We allow
 	 the read to be interrupted if we caught SIGHUP, SIGTERM, or any
diff --git a/kill.c b/kill.c
index 4cf933b..2695b1b 100644
--- a/kill.c
+++ b/kill.c
@@ -865,6 +865,7 @@ _rl_bracketed_read_mbstring (char *mb, int mlen)
 
 /* A special paste command for Windows users. */
 #if defined (_WIN32)
+#define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 
 int
diff --git a/rldefs.h b/rldefs.h
index 98577a6..c49af8b 100644
--- a/rldefs.h
+++ b/rldefs.h
@@ -40,7 +40,7 @@
 #  if defined (HAVE_TERMIO_H)
 #    define TERMIO_TTY_DRIVER
 #  else
-#    if !defined (__MINGW32__)
+#    if !defined (__MINGW32__) && 0
 #      define NEW_TTY_DRIVER
 #    else
 #      define NO_TTY_DRIVER
diff --git a/rlprivate.h b/rlprivate.h
index d87d07a..08e98f5 100644
--- a/rlprivate.h
+++ b/rlprivate.h
@@ -303,10 +303,12 @@ extern int _rl_pushed_input_available (void);
 
 extern int _rl_timeout_init (void);
 extern int _rl_timeout_handle_sigalrm (void);
+#if 0
 #if defined (_POSIXSELECT_H_)
 /* use as a sentinel for fd_set, struct timeval,  and sigset_t definitions */
 extern int _rl_timeout_select (int, fd_set *, fd_set *, fd_set *, const struct timeval *, const sigset_t *);
 #endif
+#endif
 
 /* isearch.c */
 extern _rl_search_cxt *_rl_scxt_alloc (int, int);
diff --git a/support/wcwidth.c b/support/wcwidth.c
index 0f5ec99..c7e0d56 100644
--- a/support/wcwidth.c
+++ b/support/wcwidth.c
@@ -71,7 +71,7 @@ struct interval {
 };
 
 /* auxiliary function for binary search in interval table */
-static int bisearch(wchar_t ucs, const struct interval *table, int max) {
+static int bisearch(WCHAR_T ucs, const struct interval *table, int max) {
   int min = 0;
   int mid;
 
@@ -123,7 +123,7 @@ static int bisearch(wchar_t ucs, const struct interval *table, int max) {
  * in ISO 10646.
  */
 
-int mk_wcwidth(wchar_t ucs)
+int mk_wcwidth(WCHAR_T ucs)
 {
   /* sorted list of non-overlapping intervals of non-spacing characters */
   /* generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c" */
@@ -208,7 +208,7 @@ int mk_wcwidth(wchar_t ucs)
 }
 
 
-int mk_wcswidth(const wchar_t *pwcs, size_t n)
+int mk_wcswidth(const WCHAR_T *pwcs, size_t n)
 {
   int w, width = 0;
 
@@ -231,7 +231,7 @@ int mk_wcswidth(const wchar_t *pwcs, size_t n)
  * the traditional terminal character-width behaviour. It is not
  * otherwise recommended for general use.
  */
-int mk_wcwidth_cjk(wchar_t ucs)
+int mk_wcwidth_cjk(WCHAR_T ucs)
 {
   /* sorted list of non-overlapping intervals of East Asian Ambiguous
    * characters, generated by "uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c" */
@@ -299,7 +299,7 @@ int mk_wcwidth_cjk(wchar_t ucs)
 }
 
 
-int mk_wcswidth_cjk(const wchar_t *pwcs, size_t n)
+int mk_wcswidth_cjk(const WCHAR_T *pwcs, size_t n)
 {
   int w, width = 0;
 
